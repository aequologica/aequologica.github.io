<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <style>
    body {
      font: 10px sans-serif;
    }

    .axis path,
    .axis line {
      fill: none;
      stroke: #000;
      shape-rendering: crispEdges;
    }

    .line {
      fill: none;
      stroke: steelblue;
      stroke-width: 2px;
    }

    #chart {
      width: 100%;
      height: 100%;
      position: absolute;
    }
  </style>
</head>

<body>

  <svg id="chart"></svg>

  <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.15/lodash.min.js"
    integrity="sha256-VeNaFBVDhoX3H+gJ37DpT/nTuZTdjYro9yBruHjVmoQ=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3@5.15.1/dist/d3.min.js"
    integrity="sha256-SQJ/nCYPXFPuqoS56EfnesDBPNiitndOIfN2WdPRi/o=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/moment@2.24.0/moment.min.js"></script>

  <!-- https://github.com/doowb/sma -->
  <!-- script src="https://cdn.jsdelivr.net/npm/sma@0.1.1/index.min.js"></script -->
  <script src="sma.js"></script>

  <script>

    // Define margins
    var margin = { top: 20, right: 80, bottom: 30, left: 50 },
      width =
        parseInt(d3.select("#chart").style("width")) - margin.left - margin.right,
      height =
        parseInt(d3.select("#chart").style("height")) - margin.top - margin.bottom;

    // Define date parser
    var parseDate = d3.timeParse("%Y-%m-%d");

    // Define scales
    var xScale = d3.scaleTime().range([0, width]);
    var yScale = d3.scaleLinear().range([height, 0]);
    var color = d3.scaleOrdinal().range(d3.schemeCategory10);

    // Define axes
    var xAxis = d3.axisBottom().scale(xScale);
    var yAxis = d3.axisLeft().scale(yScale);

    // Define lines
    var line = d3
      .line()
      .curve(d3.curveMonotoneX)
      .x(function (d) {
        return xScale(d["date"]);
      })
      .y(function (d) {
        return yScale(d["deltaMovingAverage"]);
      });

    // Define svg canvas
    var svg = d3
      .select("#chart")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
      .append("g")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    // Read in data
    d3.json("https://pomber.github.io/covid19/timeseries.json").then(function (data) {

      data = { France: data.France, Italy: data.Italy, US: data.US, Spain: data.Spain };

      // Set the color domain equal to the three product categories
      var countries = ["France", "Italy", "US", "Spain"];
      color.domain(countries);

      // console.log(JSON.stringify(data, null, 2)) // to view the structure

      // Format the data field
      countries.forEach(function (p) {

        var start = moment("2020-03-08");
        var sizeOfAverage = 4;
        var prev = 0;

        data[p].forEach(function (d) {
          d.date = parseDate(d.date);
          d.deaths = +d.deaths;
          d.delta = d.deaths - prev;
          prev = d.deaths;
        });

        var deltas = _.map(data[p], 'delta');
        var deltasMovingAverage = sma(deltas, sizeOfAverage);

        var i = 0;
        data[p].forEach(function (d) {
          d.deltaMovingAverage = i < sizeOfAverage ? 0 : deltasMovingAverage[i - sizeOfAverage];
          i = i + 1;
        });

        data[p] = _.filter(data[p], function (d) { return moment(d.date).isSameOrAfter(start); });

      });

      // Reformat data to make it more copasetic for d3
      // data = An array of objects
      // deathss = An array of three objects, each of which contains an array of objects
      var deathss = countries.map(function (country) {
        return {
          category: country,
          datapoints: data[country] /*map(function (d) {
            return { date: d.date, deaths: d.deaths, delta: d.delta, deltaMovingAverage: d.deltaMovingAverage };
          })*/
        };
      });

      // console.log(JSON.stringify(deathss, null, 2)) // to view the structure

      // Set the domain of the axes
      xScale.domain(
        d3.extent(deathss[2].datapoints, function (d) {
          return d.date;
        })
      );

      yScale.domain(
        d3.extent(deathss[2].datapoints, function (d) {
          return d.delta;
        })
      );

      // Place the axes on the chart
      svg
        .append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + height + ")")
        .call(xAxis);

      svg
        .append("g")
        .attr("class", "y axis")
        .call(yAxis)
        .append("text")
        .attr("class", "label")
        .attr("y", 6)
        .attr("dy", ".71em")
        .attr("dx", ".71em")
        .style("text-anchor", "beginning")
        .text("");

      var products = svg
        .selectAll(".category")
        .data(deathss)
        .enter()
        .append("g")
        .attr("class", "category");

      products
        .append("path")
        .attr("class", "line")
        .attr("d", function (d) {
          return line(d.datapoints);
        })
        .style("stroke", function (d) {
          return color(d.category);
        });

      // console.log(JSON.stringify(d3.values(deathss), null, 2)) // to view the structure
      // console.log(d3.values(deathss)); // to view the structure
      // console.log(deathss);
      // console.log(deathss.map(function()))
    });

    // Define responsive behavior
    function resize() {
      var width =
        parseInt(d3.select("#chart").style("width")) - margin.left - margin.right,
        height =
          parseInt(d3.select("#chart").style("height")) -
          margin.top -
          margin.bottom;

      // Update the range of the scale with new width/height
      xScale.range([0, width]);
      yScale.range([height, 0]);

      // Update the axis and text with the new scale
      svg
        .select(".x.axis")
        .attr("transform", "translate(0," + height + ")")
        .call(xAxis);

      svg.select(".y.axis").call(yAxis);

      // Force D3 to recalculate and update the line
      svg.selectAll(".line").attr("d", function (d) {
        return line(d.datapoints);
      });

      // Update the tick marks
      xAxis.ticks(Math.max(width / 75, 2));
      yAxis.ticks(Math.max(height / 50, 2));
    }

    // Call the resize function whenever a resize event occurs
    d3.select(window).on("resize", resize);

    // Call the resize function
    resize();


  </script>
</body>

</html>